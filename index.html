<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="gao&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Gaomy&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Gaomy&#39;s blog">
<meta property="og:description" content="gao&apos;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gaomy&#39;s blog">
<meta name="twitter:description" content="gao&apos;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Gaomy's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gaomy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/跨域/" itemprop="url">跨域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T14:43:22+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="同源策略："><a href="#同源策略：" class="headerlink" title="同源策略："></a>同源策略：</h4><p>只允许与本域下的接口进行交互</p>
<p> 不同源客户端脚本在没有对方许可情况下不能访问对方的资源</p>
<h4 id="前端跨域策略"><a href="#前端跨域策略" class="headerlink" title="前端跨域策略"></a>前端跨域策略</h4><h5 id="1-w3c标准—cors-跨域资源共享-—【需要服务端配合】"><a href="#1-w3c标准—cors-跨域资源共享-—【需要服务端配合】" class="headerlink" title="1. w3c标准—cors(跨域资源共享)—【需要服务端配合】"></a>1. w3c标准—cors(跨域资源共享)—【需要服务端配合】</h5><p>浏览器发现是一个跨域的请求后会做一些事情，需要服务端的支持，前端不用做额外的工作</p>
<h6 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h6><p>过程： </p>
<p>如果是一个简单请求，浏览器自动请求的头信息上会加上<strong>“Origin”</strong>的字段，表示请求来自哪个源，（协议+域名：端口）服务端可以拿到这个值，判断是否同意这次请求，并返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 请求</span><br><span class="line"></span><br><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: https://api.qiutc.me</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>
<p>情况一：服务端允许这次跨域请求</p>
<p>返回的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 返回</span><br><span class="line">Access-Control-Allow-Origin: https://api.qiutc.me</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: Info</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>这三个字段的意思是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:</span><br></pre></td></tr></table></figure>
<p>他的值是： 请求时Origin字段的值或者 <code>*</code> </p>
<p>*： 表示允许任意源的请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccess-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>Boolean:</p>
<p>表示是否允许发送Cookie。默认情况下，<strong>Cookie不包括在CORS请求之中</strong>。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器,</p>
<p>再发送cookie的时候还要在Ajax请求中打开withCredentials 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>
<p>如果要发送Cookie，Access-Control-Allow-Origin就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers:</span><br></pre></td></tr></table></figure>
<p>CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，<code>getResponseHeader(&#39;Info&#39;)</code>可以返回Info字段的值.</p>
<p>情况二：服务端拒绝</p>
<p>当然我们为了防止接口被乱调用，需要限制源，对于不允许的源，服务端还是会返回一个正常的HTTP回应，但是不会带上 <code>Access-Control-Allow-Origin</code> 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调捕获到。</p>
<p><strong>这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200</strong></p>
<h6 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h6><p>对服务器有特殊的要求，请求访求方法：</p>
<p>PUT或DELETE</p>
<p>Content-Type字段的类型是 application/json</p>
<p>过程：</p>
<p>请求过程分为2个部分</p>
<p>1.预检请求</p>
<p>在正式请求之前，增加一次查询，称为预检请求（preflight）</p>
<p>请求方法是 OPTIONS —该请求是用来询问的</p>
<p>询问：</p>
<p>网页当前的域名是否在服务器的许可名单之内，</p>
<p>可以选用的请求方法</p>
<p>可以使用的头信息</p>
<p>具体的请求头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS: /cors HTTP/1.1   </span><br><span class="line">//options 表示该请求时用来询问的</span><br><span class="line">Origin: 请求来源</span><br><span class="line">Access-Control-Request-Method: Put</span><br><span class="line">Access-Control-Request-Headers: </span><br><span class="line">Host: </span><br><span class="line">Accept-Lanuage: en-US</span><br></pre></td></tr></table></figure>
<ul>
<li>Access-Control-Request-Method： put</li>
</ul>
<p>浏览器可能使用的cors请求的方法</p>
<ul>
<li>Access-Control-Request-Headers</li>
</ul>
<p>指定浏览器CORS请求会额外发送的头信息字段，用 ,  分割</p>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: https://api.qiutc.me</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<ul>
<li>Access-Control-Allow-Methods:</li>
</ul>
<p>返回服务端支持的跨域请求的方法，不限于浏览器发过去的那些</p>
<ul>
<li>Access-Control-Allow-Headers</li>
</ul>
<p>同上</p>
<ul>
<li>Access-Control-Max-Age</li>
</ul>
<p>预检请求的有效期（m）在期限内不用再发出预检请求</p>
<p>使用cors 的写法就与普通的ajax的请求方式一样</p>
<p>服务端的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;);</span><br></pre></td></tr></table></figure>
<p>cors: ie 11支持</p>
<h5 id="2-jsonp"><a href="#2-jsonp" class="headerlink" title="2.jsonp"></a>2.jsonp</h5><p>写法丑陋，兼容性好，只能发送 get请求</p>
<h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function resolveJosn(result) &#123;</span><br><span class="line">	console.log(result.name);</span><br><span class="line">&#125;</span><br><span class="line">var jsonpScript= document.createElement(&quot;script&quot;);</span><br><span class="line">jsonpScript.type = &quot;text/javascript&quot;;</span><br><span class="line">jsonpScript.src = &quot;https://www.qiute.com?callbackName=resolveJson&quot;;</span><br><span class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonpScript);</span><br></pre></td></tr></table></figure>
<p>动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。</p>
<h6 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h6><p>在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是<code>resolveJson</code>。然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolveJson(&#123;name: &apos;qiutc&apos;&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h6><p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	$(&apos;.change&apos;).addEventListener(&apos;click&apos;,function ()&#123;</span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        script.src = &apos;http://a.xx.com:8080/getNews?callback=appendHtml&apos;;</span><br><span class="line">        document.head.appendChild(script);</span><br><span class="line">        document.head.removeChild(script); </span><br><span class="line">	&#125;)</span><br><span class="line">	function appendHtml(news) &#123;</span><br><span class="line">        console.log(news);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>服务端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/getNews&apos;,function(req,res) &#123;</span><br><span class="line">    var news = [</span><br><span class="line">        &quot;a:asdhakj&quot;,</span><br><span class="line">        &quot;b：吉萨大环境宽松&quot;,</span><br><span class="line">        &quot;c: &apos;sda&apos;&quot;</span><br><span class="line">    ];</span><br><span class="line">    var data = [];</span><br><span class="line">    for(let i = 0;i&lt;3;i++) &#123;</span><br><span class="line">        let index = parseInt(Math.random()*news.length);</span><br><span class="line">        data.push(news[index]);</span><br><span class="line">        news.splice(index,1);</span><br><span class="line">    &#125;</span><br><span class="line">    var cb = req.query.callback;</span><br><span class="line">    if(cb) &#123;</span><br><span class="line">     res.send(cb+&apos;(&apos;+JSON.stringify(data)+&apos;)&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     res.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实际上是去加载 <a href="http://a.xx.com:8080/getNews?callback=appendHtml，这个文件，然后当作" target="_blank" rel="noopener">http://a.xx.com:8080/getNews?callback=appendHtml，这个文件，然后当作</a> js 执行</p>
<p><strong>jsonp的形式必须要后端配合才能完成</strong></p>
<h5 id="3-window-postMessage"><a href="#3-window-postMessage" class="headerlink" title="3.window.postMessage"></a>3.window.postMessage</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;iframe src=&quot;http://localhost:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class="line">	console.log(this.value);</span><br><span class="line">	window.frames[0].postMessage(this.value,&apos;*&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">window.addEventListener(&apos;message&apos;,function(e) &#123;</span><br><span class="line">		$(&apos;.main input&apos;).value = e.data</span><br><span class="line">    console.log(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot;  placeholder=&quot;http://b.jrg.com:8080/b.html&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class="line">	window.parent.postMessage(this.value, &apos;*&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">window.addEventListener(&apos;message&apos;,function(e) &#123;</span><br><span class="line">		$(&apos;#input&apos;).value = e.data</span><br><span class="line">    console.log(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只能是window的方法，场景：</p>
<p>当前页面嵌入 iframe 需要 各个iframe 之间通信。</p>
<h5 id="4-降域"><a href="#4-降域" class="headerlink" title="4.降域"></a>4.降域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; placeholder=&quot;http://a.jrg.com:8080/a.html&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;iframe src=&quot;http://b.jrg.com:8080/b.html&quot; frameborder=&quot;0&quot; &gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123;</span><br><span class="line">  console.log(this.value);</span><br><span class="line">  window.frames[0].document.querySelector(&apos;input&apos;).value = this.value;</span><br><span class="line">&#125;)</span><br><span class="line">document.domain = &quot;jrg.com&quot;</span><br></pre></td></tr></table></figure>
<p>降域名 降到具有相同域名的部分，两方同时降域 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.parent.document.querySelector(&apos;input&apos;).value = this.value</span><br></pre></td></tr></table></figure>
<p>前提： 应该是有相同的部分的域名</p>
<h5 id="5-Node-js跨域"><a href="#5-Node-js跨域" class="headerlink" title="5.Node.js跨域"></a>5.Node.js跨域</h5><h5 id="6-nginx跨域"><a href="#6-nginx跨域" class="headerlink" title="6.nginx跨域"></a>6.nginx跨域</h5><p>【1】然而nginx是实现跨域的原理是什么呢？<br>【2】是做代理接口，它去请求实际服务器，在将数据返回给我们吗？<br>【3】还是说它修改了发送方的header值，让请求的header与目标域名一致？<br><strong>【4】它具体的运行流程是怎么样的呢？</strong></p>
<p>【1】首先，直接在浏览器地址栏中，输入某接口地址。是不会产生跨域问题的。<br>只有当在某域名的页面中，由该页面发起的接口请求。才可能会跨域。<br>nginx就类似于这个浏览器，它接收到外部对它的请求（ 注意，nginx只会接收别人对它的请求，而不会拦截浏览器的请求 ），再类似浏览器地址栏一样去请求某个接口。最后将请求到的内容返回回去<br>【2】是的<br>【3】不一定会修改，可以进行修改。<br>【4】前端利用host结合nginx实现跨域的运行流程：<br>Brower =》 host =》 nginx =》 目标地址<br>服务器数据 =》 nginx =》 Brower<br>也就是说，nginx并不是通过监听brower的请求。<br>而是作为一个服务器，接收外部对本机的请求。<br>所以是先通过host，让请求指向本机，才会经过nginx。才能进行转发</p>
<p>cors on nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Wide-open CORS config for nginx</span><br><span class="line">#</span><br><span class="line">location / &#123;</span><br><span class="line">     if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;</span><br><span class="line">        #</span><br><span class="line">        # Custom headers and headers various browsers *should* be OK with but aren&apos;t</span><br><span class="line">        #</span><br><span class="line">        add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&apos;;</span><br><span class="line">        #</span><br><span class="line">        # Tell client that this pre-flight info is valid for 20 days</span><br><span class="line">        #</span><br><span class="line">        add_header &apos;Access-Control-Max-Age&apos; 1728000;</span><br><span class="line">        add_header &apos;Content-Type&apos; &apos;text/plain; charset=utf-8&apos;;</span><br><span class="line">        add_header &apos;Content-Length&apos; 0;</span><br><span class="line">        return 204;</span><br><span class="line">     &#125;</span><br><span class="line">     if ($request_method = &apos;POST&apos;) &#123;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Expose-Headers&apos; &apos;Content-Length,Content-Range&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">     if ($request_method = &apos;GET&apos;) &#123;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&apos;;</span><br><span class="line">        add_header &apos;Access-Control-Expose-Headers&apos; &apos;Content-Length,Content-Range&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx 通过转发实现跨域(API 代理转发)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass  http://127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ /api/ &#123;</span><br><span class="line">        proxy_pass  http://172.30.1.123:8081;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">监听80端口（Nginx默认启动了80端口），将http://127.0.0.1的所有请求服务转发到127.0.0.1端口为3000；</span><br><span class="line">将http://127.0.0.1/api/或者http://127.0.0.1/api/getList请求转发到http://172.30.1.123:8081</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.51cto.com/freeloda/1288553" target="_blank" rel="noopener">nginx</a></p>
<p><a href="https://juejin.im/entry/58df166a0ce463005821e9d9#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">反向代理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/25/HTTP2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/HTTP2-0/" itemprop="url">HTTP2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-25T15:30:25+08:00">
                2018-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="关于HTTP协议："><a href="#关于HTTP协议：" class="headerlink" title="关于HTTP协议："></a>关于HTTP协议：</h4><p>HTTP是建立在TCP协议之上，HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如：</p>
<p>TCP 建立连接的<strong>3次握手</strong>和断开连接的<strong>4次挥手</strong>以及每次建立<strong>连接带来的RTT延迟时间</strong>。</p>
<p>影响HTTP网络请求的因素主要有两个： 带宽和延迟</p>
<p>带宽：现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>
<h5 id="延迟："><a href="#延迟：" class="headerlink" title="延迟："></a>延迟：</h5><ol>
<li><strong>浏览器阻塞（HOL blocking）</strong>：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li>
<li><strong>DNS 查询（DNS Lookup）</strong>：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的</li>
<li><strong>建立连接（Initial connection）</strong>：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和<a href="http://en.wikipedia.org/wiki/Slow-start" target="_blank" rel="noopener">慢启动</a>。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li>
</ol>
<p><img src="http://tenny.qiniudn.com/3woshou.png" alt="img"></p>
<h5 id="关于连接"><a href="#关于连接" class="headerlink" title="关于连接"></a>关于连接</h5><p>怎么算是一个连接，HTTP 1.1 出现的keep-alive</p>
<p>每次连接都要经历三次握手和慢启动，说明HTTP的连接实际上是TCP 的连接。</p>
<h5 id="HTTP1-0和HTTP1-1的一些区别："><a href="#HTTP1-0和HTTP1-1的一些区别：" class="headerlink" title="HTTP1.0和HTTP1.1的一些区别："></a>HTTP1.0和HTTP1.1的一些区别：</h5><h6 id="1-缓存处理："><a href="#1-缓存处理：" class="headerlink" title="1.缓存处理："></a>1.缓存处理：</h6><p>HTTP1.0header使用 If-Modified-Since,Expires 等作为缓存标准的判断，HTTP1.1 引入更多的缓存策略： Entity tag, If-UnModified-Since ,If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略</p>
<h6 id="2-带宽优化及网络连接"><a href="#2-带宽优化及网络连接" class="headerlink" title="2.带宽优化及网络连接"></a>2.带宽优化及网络连接</h6><p>HTTP1.0存在一些浪费带宽的情况，HTTP1.1 添加了头部中的range,客户端可以请求资源的一部分，返回响应码（206 Partial content）</p>
<h6 id="3-错误处理的通知"><a href="#3-错误处理的通知" class="headerlink" title="3.错误处理的通知"></a>3.错误处理的通知</h6><p>新增错误处理通知的状态码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</p>
<p>409冲突：</p>
<blockquote>
<p>由于与目标资源的当前状态冲突，无法完成请求。此代码用于用户可能能够解决冲突并重新提交请求的情况。</p>
<p>服务器应该生成一个有效负载，其中包含足够的信息供用户识别冲突源。</p>
<p>冲突最有可能发生在响应PUT请求时。例如，如果正在使用版本控制并且包含PUT的表示更改为与早期（第三方）请求冲突的资源，则源服务器可能使用409响应来指示它无法完成请求。在这种情况下，响应表示可能包含对基于修订历史合并差异有用的信息。</p>
</blockquote>
<p>410（gone）</p>
<blockquote>
<p>410 Gone客户端错误响应代码表示在源服务器上不再可以访问目标资源，(永久删除)并且此条件可能是永久性的。</p>
<p>如果您不知道此缺失是暂时的还是永久性的，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404" target="_blank" rel="noopener"><code>404</code></a>则应使用状态代码。</p>
</blockquote>
<p>put请求：<a href="https://www.zhihu.com/question/48482736" target="_blank" rel="noopener">与post区别</a></p>
<p><a href="https://www.oschina.net/translate/put-or-post" target="_blank" rel="noopener">区别</a></p>
<p><a href="https://www.zhihu.com/question/48482736" target="_blank" rel="noopener">区别</a></p>
<p>put请求用于更新资源</p>
<p>post用于创建资源</p>
<h6 id="4-Host-头处理"><a href="#4-Host-头处理" class="headerlink" title="4.Host 头处理"></a>4.Host 头处理</h6><p>添加请求的主机名，HTTP1.0 的版本，认为每个IP与一个主机对应的，但是由于虚拟主机的出现，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址，所以新增了主机名</p>
<h6 id="5-长连接"><a href="#5-长连接" class="headerlink" title="5.长连接"></a>5.长连接</h6><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0：</p>
<p><img src="http://tenny.qiniudn.com/http11.png" alt="img"></p>
<p><img src="http://tenny.qiniudn.com/DIF12.png" alt="img"></p>
<h5 id="HTTP1-0-1-1现存的一些问题"><a href="#HTTP1-0-1-1现存的一些问题" class="headerlink" title="HTTP1.0 ,1.1现存的一些问题"></a>HTTP1.0 ,1.1现存的一些问题</h5><h6 id="1-HTTP1-x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出"><a href="#1-HTTP1-x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出" class="headerlink" title="1.HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出"></a>1.HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出</h6><h6 id="2-HTTP1-x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性"><a href="#2-HTTP1-x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性" class="headerlink" title="2.HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性"></a>2.HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性</h6><h6 id="3-HTTP1-x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量"><a href="#3-HTTP1-x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量" class="headerlink" title="3. HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量"></a>3. HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量</h6><h6 id="4-虽然HTTP1-x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务-例如图片存放网站-，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。"><a href="#4-虽然HTTP1-x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务-例如图片存放网站-，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。" class="headerlink" title="4.虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。"></a>4.虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</h6><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><h6 id="使用SPDY加快网站速度"><a href="#使用SPDY加快网站速度" class="headerlink" title="使用SPDY加快网站速度"></a>使用SPDY加快网站速度</h6><p>2012年google提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：</p>
<ol>
<li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li>
<li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li>
<li><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li>
<li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li>
<li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图</li>
</ol>
<p>HTTP</p>
<p>SPDY</p>
<p>SSL</p>
<p>TCP</p>
<p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p>
<h4 id="HTTP2-0的前世今生"><a href="#HTTP2-0的前世今生" class="headerlink" title="HTTP2.0的前世今生"></a>HTTP2.0的前世今生</h4><p>顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：</p>
<ul>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP2.0 消息头的压缩算法采用 <a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK</a>，而非 SPDY 采用的 <a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">DEFLATE</a></li>
</ul>
<h4 id="HTTP-2介绍"><a href="#HTTP-2介绍" class="headerlink" title="HTTP/2介绍"></a>HTTP/2介绍</h4><p>在与 HTTP/1.1 完全语义兼容的基础上，进一步减少了网络延迟，大幅度的提升了 web 性能。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="1-多路复用（Multiplexing）"><a href="#1-多路复用（Multiplexing）" class="headerlink" title="1.多路复用（Multiplexing）"></a>1.多路复用（Multiplexing）</h5><p>以下描述我认为相当准确</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/08/25/HTTP2-0/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/学习TypeScript-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/学习TypeScript-基础/" itemprop="url">学习TypeScript-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T09:08:28+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="1-关于基础类型-重点说-any、object等"><a href="#1-关于基础类型-重点说-any、object等" class="headerlink" title="1.关于基础类型(重点说 any、object等)"></a>1.关于基础类型(重点说 any、object等)</h4><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>刚开始的问题是 any 用的比较多，但是事实上，type-check 本来就是为了确定类型，写那么多不能确定类型的 any 干什么</p>
<p>适用于any的情况：</p>
<p>当我们确实不知道变量的类型的时候，需要取消类型检查。例如下面的情况(These values may come from dynamic content)</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/08/21/学习TypeScript-基础/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/现代样式：css也要模块化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/现代样式：css也要模块化/" itemprop="url">现代样式：CSS Modules</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T15:04:19+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="问题起源："><a href="#问题起源：" class="headerlink" title="问题起源："></a>问题起源：</h4><blockquote>
<p>css的全局特性：css 全部作为全局样式的形式，容易造成命名冲突</p>
</blockquote>
<p>####css 模块化的概念：</p>
<p>css 应该时有它的作用域的，即：</p>
<h4 id="发展的过程"><a href="#发展的过程" class="headerlink" title="发展的过程"></a>发展的过程</h4><p>1.在全局作用域问题上，早期的做法：</p>
<ul>
<li>OOCSS</li>
<li>BEM</li>
</ul>
<p>都是提供一种一种方式模拟健全的作用域规则，本质上还是靠程序员自身的代码规则约束，没有在根本上解决问题。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/08/20/现代样式：css也要模块化/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/08/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/ES6/" itemprop="url">ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-08T09:55:40+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、let与var </p>
<ul>
<li>let 声明具有块级作用域 (如果没有块: 用于计数的循环变量泄露为全局变量)</li>
</ul>
<p>对于一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 var 声明的变量是全局的 这里的i 就是一个，就是全局的i,每次循环 i的值都会发生变化，赋给数组的函数内部的console.log(i) 指的就是外部的i</p>
<blockquote>
<p>理解: 数组元素的[i] 与console.log(i)的i 不同,元素这里是立即会获取 增长的i 但是 console.log(i) 只是一个声明,在执行的时候,再去拿i 的值,它拿到的i 的值,是最后增长结束的 i的值,下面这样会有不同</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>立即执行的话，会不同 就是输出理想的 1-9</p>
<p>如果使用 let</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure>
<p>这里 i 就是在本轮循环中有效，每次循环的i 都是一个新的变量</p>
<p> JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算</p>
<p><code>for</code>循环还有一个特别之处，</p>
<blockquote>
<p>就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i = &apos;abc&apos;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br><span class="line">// abc</span><br></pre></td></tr></table></figure>
<ul>
<li>let 声明 不存在变量提升</li>
</ul>
<p>var 声明变量,会发生提升,变量可以在声明之前使用 值 为 undefined</p>
<ul>
<li>声明之前是不能使用的（临时性死区）</li>
</ul>
<ul>
<li>不允许重复声明</li>
</ul>
<p>不能在函数内部重新声明参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">  let arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    let arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有块级作用域  易造成 用于计数的循环变量泄露为全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<p>const  声明一个只读的常量</p>
<p>本质: </p>
<blockquote>
<p>并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动.</p>
<p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</span><br></pre></td></tr></table></figure>
<p>理解一下：</p>
<p>foo 指向的是一个内存地址这个地址指向了一个数组或者对象，使用const 声明后，这个地址就只能一直指向这一个 数组或者对象，不能指向其他</p>
<blockquote>
<p>常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(&apos;Hello&apos;); // 可执行</span><br><span class="line">a.length = 0;    // 可执行</span><br><span class="line">a = [&apos;Dave&apos;];    // 报错</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错</p>
</blockquote>
<p>如果需要冻结一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure>
<p>ES6 中声明变量</p>
<blockquote>
<p>从 ES6 开始 全局变量将逐步与顶层对象的属性脱钩。<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>
</blockquote>
<p>顶层对象不统一</p>
<ul>
<li>浏览器顶层是 window,Node 和web worker 没有window</li>
<li>浏览器和 web worker  self 指向顶层，但Node没有self</li>
<li>Node 顶层是 global,其他环境都不支持。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/03/HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/HTTPS/" itemprop="url">HTTPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T18:40:59+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h4><p>本质上是：基于SSL/TSL构建的通道，再叠加HTTP的通信，在这个通道协议保护下，S/C之间的通信可以在不可信的网络中保密的传输，</p>
<p>SSL/TLS 保护整个上层应用协议的通信包，</p>
<p>域名不加密</p>
<p>超文本传输协议安全（HTTPS）是HTTP的安全版本，HTTP是在浏览器和您连接的网站之间发送数据的协议。HTTPS末尾的“S”代表“安全”。这意味着您的浏览器和网站之间的所有通信都是加密的。</p>
<p>HTTPS通常用于保护高度机密的在线交易，如网上银行和在线购物订单。</p>
<p>受保护的信息包括<strong>Cookie，用户代理详细信息，URL路径，表单提交和查询字符串参数</strong>。HTTPS旨在防止在传输过程中读取或更改此信息</p>
<p>Internet Explorer，Firefox和Chrome等Web浏览器也会在地址栏中显示挂锁图标，以直观地指示HTTPS连接有效。</p>
<h4 id="HTTPS如何工作"><a href="#HTTPS如何工作" class="headerlink" title="HTTPS如何工作"></a>HTTPS如何工作</h4><p>HTTPS页面通常使用两种安全协议之一来加密通信 - <a href="https://www.instantssl.com/ssl.html" target="_blank" rel="noopener">SSL（安全套接字层）</a>或TLS（传输层安全性）。TLS和SSL协议都使用所谓的“非对称”公钥基础结构（PKI）系统。非对称系统使用两个“密钥”来加密通信，一个“公共”密钥和一个“私有”密钥。使用公钥加密的任何内容只能通过私钥解密，反之亦然。</p>
<p>“私人”密钥应该受到严格保护，并且只能由私钥的所有者访问。对于网站，私钥仍然安全地存放在Web服务器上。相反，公钥旨在分发给任何需要能够解密用私钥加密的信息的人和每个人。</p>
<h4 id="什么是-SSL证书"><a href="#什么是-SSL证书" class="headerlink" title="什么是 SSL证书"></a>什么是 SSL证书</h4><p>两个作用：</p>
<ul>
<li>验证服务器的身份</li>
<li>对传输的数据进行加密、保证其完整性及隐私性</li>
</ul>
<p>当您请求与网页建立HTTPS连接时，网站最初会将其SSL证书发送到您的浏览器。此证书包含开始安全会话所需的公钥。根据此初始交换，您的浏览器和网站然后启动“SSL握手”。SSL握手涉及生成共享机密以在您自己和网站之间建立唯一安全的连接。</p>
<p>证书颁发机构<a href="https://https.cio.gov/#footnote-2" target="_blank" rel="noopener">[2]</a>可以代表Web服务所有者颁发加密签名证书。这些证书向客户端传达Web服务主机在证书颁发时向证书颁发机构证明域的所有权。这可以防止未知或不受信任的网站伪装成联邦网站或服务。</p>
<h4 id="为什么需要证书"><a href="#为什么需要证书" class="headerlink" title="为什么需要证书"></a>为什么需要证书</h4><p>通过常规HTTP连接发送的所有通信都是<strong>“纯文本”</strong>，任何黑客都可以读取，这些黑客会破坏浏览器和网站之间的连接。如果“通信”在订单上并且包含您的信用卡详细信息或社会安全号码，则存在明显的危险。通过HTTPS连接，所有通信都是安全加密的。这意味着即使有人设法闯入连接，他们也无法解密您和网站之间传递的任何数据。</p>
<h4 id="HTTPS-证书的好处"><a href="#HTTPS-证书的好处" class="headerlink" title="HTTPS 证书的好处"></a>HTTPS 证书的好处</h4><p>通过常规HTTP连接发送的所有通信都是“纯文本”，任何黑客都可以读取，这些黑客会破坏浏览器和网站之间的连接。如果“通信”在订单上并且包含您的信用卡详细信息或社会安全号码，则存在明显的危险。通过HTTPS连接，所有通信都是安全加密的。这意味着即使有人设法闯入连接，他们也无法解密您和网站之间传递的任何数据。</p>
<h4 id="HTTPS-不做什么"><a href="#HTTPS-不做什么" class="headerlink" title="HTTPS 不做什么"></a>HTTPS 不做什么</h4><p>HTTPS有几个重要的限制。通信期间<strong>未加密IP地址和目标域名</strong>。即使是加密的流量也可以间接地泄露某些信息，例如在网站上花费的时间，或者请求的资源或提交的信息的大小。</p>
<p>HTTPS仅保证两个系统之间连接的完整性，而不是系统本身。它的目的不是保护Web服务器不被黑客入侵或泄露，或者防止Web服务在正常操作期间暴露用户信息。同样，如果攻击者破坏了用户的系统，则可以更改该系统，以使其未来的HTTPS连接受到攻击者的控制。HTTPS的保证也可能被受损或恶意的证书颁发机构削弱或消除</p>
<h4 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h4><p>连接建立在TCP 握手之后、发送/接受HTTP请求之前，HTTPS通过SSL/TLS握手的SSL/TLS协议在客户端和服务器之间建立协商，</p>
<p>目标：</p>
<ul>
<li>确保客户端与正确的服务器通信</li>
<li>商定一个双方都支持的密码套件（加密算法等）</li>
<li>获得对于各方能够具有对于算法来说必要的商定的密钥</li>
</ul>
<p>ssL的handshake</p>
<p><img src="https://blog.cystack.net/content/images/2017/10/1_H4mkE3627sQSXkuUeVoUaQ-1-.png" alt="SSLæ¡æ"></p>
<h4 id="加密什么"><a href="#加密什么" class="headerlink" title="加密什么"></a>加密什么</h4><p>加密几乎一切传递的数据（除了IP和域名）</p>
<h4 id="加密了就保证了安全吗"><a href="#加密了就保证了安全吗" class="headerlink" title="加密了就保证了安全吗"></a>加密了就保证了安全吗</h4><h4 id="影响性能速度如何处理"><a href="#影响性能速度如何处理" class="headerlink" title="影响性能速度如何处理"></a>影响性能速度如何处理</h4><h4 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 客户端向服务端发送请求 </span><br><span class="line">   -&gt; 服务端返回数字证书 </span><br><span class="line">	-&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书,如果证书有问题会提示风险 </span><br><span class="line">	    -&gt; 如果证书没问题客户端会生成一个对称加密的随机秘钥然后再和刚刚解密的服务器端的公钥对数据进行加密,然后发送给服务器端 </span><br><span class="line">		  -&gt; 服务器端收到以后会用自己的私钥对客户端发来的对称秘钥进行解密 </span><br><span class="line">			-&gt; 之后双方就拿着这个对称加密秘钥来进行正常的通信</span><br></pre></td></tr></table></figure>
<h4 id="加解密算法"><a href="#加解密算法" class="headerlink" title="加解密算法"></a>加解密算法</h4><h6 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1.对称加密"></a>1.对称加密</h6><p>分为：</p>
<p>流式、分组两种 加密解密使用同一个密钥</p>
<p>主要有： <strong>DES、AES-GCM、ChaCha20-Ploy1305、AES，RC4，3DES</strong>  等</p>
<p>简单了解原理：</p>
<p>DES:</p>
<p>AES-GCM:</p>
<p>ChaCha20-Ploy1305:</p>
<h6 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h6><p>加密密钥与解密密钥不同，称为：公钥、私钥 </p>
<p>使用公钥加密的只能用私钥解密，相反同理</p>
<p>公钥和算法都是公开的，私钥是保密的。</p>
<p>非对称加密算法性能较低，（密钥交换等过程耗费）但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>
<p>非对称加密算法性能低的原因：</p>
<p>非对称加密算法：</p>
<p>RSA（见的比较多）、DSA、ECDSA、DH、ECDHE</p>
<h6 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3.哈希算法"></a>3.哈希算法</h6><p>任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆</p>
<p>例如： MD5、SHA-1、SHA-2、SHA-256</p>
<h6 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4.数字签名"></a>4.数字签名</h6><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改</p>
<p><a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">在线版HTTPS网站检测工具</a></p>
<p>会对HTTPS网站的证书链、安全性、性能、协议细节进行全面检测，检测完毕后会进行打分，同时给出一份详细的检测报告和改进建议。</p>
<h4 id="提高HTTPS网站的性能和访问速度"><a href="#提高HTTPS网站的性能和访问速度" class="headerlink" title="提高HTTPS网站的性能和访问速度"></a>提高HTTPS网站的性能和访问速度</h4><p>误区： 并不是你加了TLS 证书，你的网站就是HTTPS网站了</p>
<p>加上证书，通常网站的速度会变慢，原因：</p>
<p>1.HTTPS 比HTTP <strong>通信时产生更多的通信过程，</strong>RTT 时间增加</p>
<p>2.通信过程中的<strong>非对称和对称加密计算</strong>也会造成更多的服务器性能和时间上的消耗</p>
<h5 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h5><h6 id="1-HSTS（HTTP-Strict-Transport-Security）"><a href="#1-HSTS（HTTP-Strict-Transport-Security）" class="headerlink" title="1.HSTS（HTTP Strict Transport Security）"></a>1.HSTS（HTTP Strict Transport Security）</h6><p>HTTPS网站通常的做法是对HTTP的访问在服务器端做302跳转，跳转到HTTPS.,但是存在一些问题</p>
<ol>
<li>使用不安全的HTTP协议进行通信；</li>
</ol>
<ol>
<li>增加一个Round-Trip Time</li>
</ol>
<p>HSTS是HTTP Strict Transport Security的缩写，服务器端配置支持HSTS后，会在给浏览器返回的HTTP Header中携带HSTS字段，浏览器在获取到该信息后，在接下来的一段时间内，对该网站的所有HTTP访问，浏览器都将请求在内部做307跳转到HTTPS，而无需任何网络过程</p>
<h6 id="2-Session-Resume（会话复用）"><a href="#2-Session-Resume（会话复用）" class="headerlink" title="2.Session Resume（会话复用）"></a>2.Session Resume（会话复用）</h6><p>是提升HTTPS网站性能最基础也是最有效的方法。</p>
<p>在HTTPS握手阶段，对服务器性能消耗最为严重的是非对称密钥交换计算，而Session Resume通过对已经建立TLS会话的合理复用，节省非对称密钥交换计算次数，可大幅提高服务器的TLS性能</p>
<p><img src="https://blog.wilddog.com/wp-content/uploads/2015/09/0-33.jpeg" alt="0 (33)"></p>
<p>TLS协议提供两种实现机制Session Resume，分别是Session cache和Session ticket。</p>
<p><strong>Session Cache</strong></p>
<p>Session Cache的原理是使用Session ID查询服务器上的session cache，如果命中，则直接使用缓存信息。但Session Cache有个明显的缺点，它不支持分布式缓存，只支持单机进程间的共享缓存。这对于多个接入节点的架构很难适用。</p>
<p><strong>Session ticket</strong></p>
<p>Session ticket的原理是服务器将session信息加密成ticket发送给浏览器，浏览器后续进行TLS握手时，会发送ticket，如果服务器能够解密和处理该ticket，则可以复用session。</p>
<p>Session ticket可以很好的解决分布式问题，但Session ticket的支持率还不是很高，而且需要考虑服务器上key的安全性方案</p>
<h6 id="3-OCSP-Stapling"><a href="#3-OCSP-Stapling" class="headerlink" title="3.OCSP Stapling"></a>3.OCSP Stapling</h6><p>在HTTPS通信过程时，浏览器会去验证服务器端下发的证书链是否已经被撤销。验证的方法有两种：CRL和OCSP。</p>
<p>CRL是证书撤销列表，CA机构会维护并定期更新CRL列表，但这个机制存在不足：</p>
<p>1.CRL列表只会越来越大；</p>
<p>2.如果浏览器更新不及时，会造成误判。</p>
<p>OCSP是实时证书在线验证协议，是对CRL机制的弥补，通过OCSP浏览器可以实时的向CA机构验证证书。但OCSP同样存在不足</p>
<ol>
<li>对CA机构要求过高，要求实时全球高可用；</li>
<li>客户端的访问隐私会在CA机构被泄露；</li>
<li>增加浏览器的握手时延。</li>
</ol>
<p>OCSP Stapling是对OCSP缺陷的弥补，服务器可事先模拟浏览器对证书链进行验证，并将带有CA机构签名的OCSP响应保存到本地，然后在握手阶段，将OCSP响应和证书链一起下发给浏览器，省去浏览器的在线验证过程。</p>
<h6 id="4-SPDY和HTTP-2"><a href="#4-SPDY和HTTP-2" class="headerlink" title="4.SPDY和HTTP/2"></a>4.SPDY和HTTP/2</h6><p>SPDY 是 Google 推出的优化 HTTP 传输效率的协议，采用多路复用方式，能将多个 HTTP 请求在同一个连接上一起发出去，对HTTP通信效率提升明显。HTTP2.0是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型。SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>
<p>Nginx stable版本当前只能支持到SPDY3.1，但最新发布的1.9.5版本通过打patch的方式，可以支持HTTP2.0，这绝对是不一样的奇妙体验。不过不建议直接在线上环境部署，等到2015年年底吧，Nginx会发布Stable版本支持HTTP2.0.</p>
<h6 id="5-TCP-优化"><a href="#5-TCP-优化" class="headerlink" title="5.TCP 优化"></a>5.TCP 优化</h6><p>慢启动是TCP规范中很重要的算法，其目的是为避免网络拥塞。通过客户端和服务器之间的数据交换，从一个很保守的初始拥塞窗口值，收敛到双方都认可的可用带宽。当客户端和服务器收敛到一定带宽时，如果一段时间内，双方没有收发数据包，服务器端的拥塞窗口会被重置为初始拥塞窗口值。这对于连接中的突发数据传输性能影响是很严重的。</p>
<p><strong>在没有充足的理由时，服务器端需要禁用空闲后的慢启动机制。</strong></p>
<p>另外，当前浏览器和服务器之间的可用带宽已经相对较大，所以我们还应该将初始的拥塞窗口值扩大，新的RFC中的建议是10，Google是16。</p>
<h6 id="6-TLS-Record-Size"><a href="#6-TLS-Record-Size" class="headerlink" title="6.TLS Record Size"></a>6.TLS Record Size</h6><p>服务器在建立TLS连接时，会为每个连接分配Buffer，这个Buffer叫TLS Record Size。这个Size是可调。</p>
<p>Size值如果过小，头部负载比重就会过大，最高可达6%。</p>
<p>Size值如果过大，那单个Record在TCP层会被分成多个包发送。浏览器必须等待这些全部达到后，才能解密，一旦出现丢包、拥塞、重传、甚至重新建立的情况，时延就会被相应增加。</p>
<p>那TLS Record Size值如何选择呢？有两个参数可参考。</p>
<p>首先，TLS Record Size要大于证书链和OCSP Stapling响应大小，证书链不会分成多个record；</p>
<p>其次，要小于初始拥塞窗口值，保证服务器在通信之初可以发送足够数据而不需要等待浏览器确认</p>
<p>一般来说，从根CA机构申请的证书为2-3KB左右，级数越多，证书链越大，ocsp响应为2KB左右，所以TLS Record Size是需要根据你的实际情况设置，Google的值5KB。WildDog当前的值是6KB</p>
<h6 id="7-证书链完整且不冗余"><a href="#7-证书链完整且不冗余" class="headerlink" title="7.证书链完整且不冗余"></a>7.证书链完整且不冗余</h6><p>浏览器在验证服务器下发的证书链时，不仅仅验证网站证书。如果是多级证书，网站证书和根证书之间所有的中间证书都需要被验证。一旦出现证书链出现不完整，浏览器就会暂停握手过程，自行到因特网进行验证，这个时间基本是不可估算的。</p>
<p>至于怎么查看，通过openssl命令查看，也可以通过SSL Labs帮你在线检测。</p>
<h6 id="8-移动设备上的ChaCha20-Poly1305"><a href="#8-移动设备上的ChaCha20-Poly1305" class="headerlink" title="8.移动设备上的ChaCha20-Poly1305"></a>8.移动设备上的ChaCha20-Poly1305</h6><p>ChaCha20被用来加密，Poly1305被用来消息认证，两个操作都需要运行于TLS上。</p>
<p>当前流行的加密套件AES-GCM在TLS 1.2支持，它是不安全RC4和AES-CBC加密套件的替代品。但是，在不支持硬件AES的设备上会引起性能问题，如大部分的智能手机、平板电脑、可穿戴设备。</p>
<p>SSL Handshake过程中服务器端RSA2048解密操作可以用专用硬件做加速来大大提升握手效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/TypeScript实践-错误处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/TypeScript实践-错误处理/" itemprop="url">TypeScript实践-错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T15:41:00+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>1、错误 “import sources within a group must be alphabetized”</p>
<p>是说 引入资源，应该有顺序</p>
<p>需要使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as source1 from &apos;../../../A&apos;</span><br><span class="line">import * as source2 from &apos;../../../B&apos;</span><br><span class="line">import * as source1 from &apos;../../C&apos;</span><br><span class="line">import * as source1 from &apos;../../D&apos;</span><br></pre></td></tr></table></figure>
<p>报错的时候会有提示比如： 【4，1】</p>
<p>会有一个行提示，在比如上面的4，第四行打上空格试试</p>
<p>2、对于使用 injectIntl函数导致的 实参与形参 类型不一致的问题</p>
<p>报错：</p>
<p>Argument of type  xx is not assignable to xx   &lt;Iprops&amp; InjectIntlProps&gt;</p>
<p>对于 在injetIntl()函数中的参数问题，阅读文档之后，发现其需要传入的是一个 ReactClass 类型，但是此时的HomePage 是一个ReactClass ,只是在定义这个类的时候对Props,States使用了接口声明类型，不明白到底是因为什么导致了这个错误</p>
<p>使用了 对HomePage 不进行类型检查的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InjectIntl(HomePage as any)</span><br></pre></td></tr></table></figure>
<p>在查找的过程中了解到一个泛型的概念也会导致这种错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare function decorate &lt;T&gt;() (component: T) =&gt; T</span><br><span class="line">class Foo&#123;</span><br><span class="line">    derp () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 decorate函数的错误方式</p>
<p>decorate<foo>() (Foo)</foo></p>
<p>正确的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decorate&lt;typeof Foo&gt; ()(Foo)</span><br><span class="line">decorate&lt;Foo&gt; () (new Foo)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/08/01/TypeScript实践-错误处理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/HTTP协议状态码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/31/HTTP协议状态码/" itemprop="url">HTTP协议状态码-301、302& Canonical Tags</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T22:04:33+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>详细看了几篇HTTP状态码的文章，在此做出总结与思考</p>
<p>201—POST 请求、ETag 、创建文件相关</p>
<p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回</p>
<p>说明：</p>
<p>1、<code>HTTP POST</code>请求的结果，<strong>已</strong>在服务器上<strong>成功创建</strong>了<strong>一个或多个新资源</strong>。</p>
<p>2、HTTP headers 中Location header field 包含 URI，指示了创建的资源的位置。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/07/31/HTTP协议状态码/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/assets/img/pic.jpg"
                alt="Gaomy" />
            
              <p class="site-author-name" itemprop="name">Gaomy</p>
              <p class="site-description motion-element" itemprop="description">gao's blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gaomy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
