<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="TypeScript," />










<meta name="description" content="1.关于基础类型(重点说 any、object等)any刚开始的问题是 any 用的比较多，但是事实上，type-check 本来就是为了确定类型，写那么多不能确定类型的 any 干什么 适用于any的情况： 当我们确实不知道变量的类型的时候，需要取消类型检查。例如下面的情况(These values may come from dynamic content)  from the user  f">
<meta name="keywords" content="TypeScript">
<meta property="og:type" content="article">
<meta property="og:title" content="学习TypeScript-基础">
<meta property="og:url" content="http://yoursite.com/2018/08/21/学习TypeScript-基础/index.html">
<meta property="og:site_name" content="Gaomy&#39;s blog">
<meta property="og:description" content="1.关于基础类型(重点说 any、object等)any刚开始的问题是 any 用的比较多，但是事实上，type-check 本来就是为了确定类型，写那么多不能确定类型的 any 干什么 适用于any的情况： 当我们确实不知道变量的类型的时候，需要取消类型检查。例如下面的情况(These values may come from dynamic content)  from the user  f">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-21T12:14:59.815Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习TypeScript-基础">
<meta name="twitter:description" content="1.关于基础类型(重点说 any、object等)any刚开始的问题是 any 用的比较多，但是事实上，type-check 本来就是为了确定类型，写那么多不能确定类型的 any 干什么 适用于any的情况： 当我们确实不知道变量的类型的时候，需要取消类型检查。例如下面的情况(These values may come from dynamic content)  from the user  f">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/21/学习TypeScript-基础/"/>





  <title>学习TypeScript-基础 | Gaomy's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gaomy's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">前端</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/学习TypeScript-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gaomy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/img/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gaomy's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学习TypeScript-基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T09:08:28+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-关于基础类型-重点说-any、object等"><a href="#1-关于基础类型-重点说-any、object等" class="headerlink" title="1.关于基础类型(重点说 any、object等)"></a>1.关于基础类型(重点说 any、object等)</h4><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><p>刚开始的问题是 any 用的比较多，但是事实上，type-check 本来就是为了确定类型，写那么多不能确定类型的 any 干什么</p>
<p>适用于any的情况：</p>
<p>当我们确实不知道变量的类型的时候，需要取消类型检查。例如下面的情况(These values may come from dynamic content)</p>
<ul>
<li>from the user </li>
<li>from a 3rd party library</li>
<li>you know part of  the type，but not all of it    (Array)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line"></span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure>
<p>any是一个非常有用的方式，对于 引入 还是取消类型检查。</p>
<p><strong>与Object不同—调用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure.ifItExists(); // okay, ifItExists might exist at runtime</span><br><span class="line">notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)</span><br><span class="line"></span><br><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;.</span><br></pre></td></tr></table></figure>
<h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><p>非基础类型 使用object，i.e. </p>
<blockquote>
<p>any thing that is not <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, or <code>undefined</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); // OK</span><br><span class="line">create(null); // OK</span><br><span class="line"></span><br><span class="line">create(42); // Error</span><br></pre></td></tr></table></figure>
<h5 id="Type-assertions—"><a href="#Type-assertions—" class="headerlink" title="Type assertions—"></a>Type assertions—</h5><p>相当于强制类型转换</p>
<p>自己了解到的类型的信息比TS要多，你知道的额尸体类型的信息比现在要更具体的时候</p>
<p>两种方式写 Type assertions</p>
<ul>
<li><type> value</type></li>
<li>value as type</li>
</ul>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>
<h4 id="2-interfaces-接口"><a href="#2-interfaces-接口" class="headerlink" title="2.interfaces(接口)"></a>2.interfaces(接口)</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>注意点：</p>
<ul>
<li>实际传入的可以比接口中定义的类型<strong>多</strong>，<strong>因为只是检查必须的</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">    label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">    console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line">let myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>
<p><strong>只是检查必须的</strong></p>
<ul>
<li>接口中的可选属性</li>
<li>readonly 只能在声明时赋值，但是可以使用断言的方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] = [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">a = ro as number[];</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><strong>readonly与const</strong></li>
</ul>
<p>变量使用<code>const</code></p>
<p>属性使用<code>readonly</code></p>
</li>
<li><p>超额检查</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);</span><br></pre></td></tr></table></figure>
<p>你可能会认为此程序输入正确，因为<code>width</code>属性是兼容的，没有<code>color</code>属性存在，并且额外的<code>colour</code>属性是无关紧要的。</p>
<blockquote>
<p>但是，TypeScript认为此代码中可能存在错误。Object literals 在将它们分配给其他变量或将它们作为参数传递时，会得到特殊处理并进行<em>多余的属性检查</em>。</p>
</blockquote>
<p><strong>如果Object literals具有“目标类型”没有的任何属性，则会出现错误。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// error: &apos;colour&apos; not expected in type &apos;SquareConfig&apos;</span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);</span><br></pre></td></tr></table></figure>
<p>colour 是多余的，target type 中是没有的</p>
<p>解决这个问题：</p>
<ol>
<li>断言</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig);</span><br></pre></td></tr></table></figure>
<h5 id="index-signature-索引签名-—"><a href="#index-signature-索引签名-—" class="headerlink" title="index signature(索引签名)—"></a>index signature(索引签名)—</h5><p>如果您确定该对象可以具有某些特殊方式使用的额外属性</p>
<p>如果<code>SquareConfig</code>能有<code>color</code>和<code>width</code>上述类型的属性，但可能<em>也</em>有任意数量的其他性质的，那么我们就可以像这样定义它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>赋值给一个变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let squareOptions = &#123; colour: &quot;red&quot;, width: 100 &#125;;</span><br><span class="line">let mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>
<p><strong>Since <code>squareOptions</code> won’t undergo excess property checks, the compiler won’t give you an error.</strong></p>
<blockquote>
<p>Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a <code>color</code> or <code>colour</code> property to <code>createSquare</code>, you should fix up the definition of <code>SquareConfig</code> to reflect that.</p>
</blockquote>
<h5 id="接口中声明函数"><a href="#接口中声明函数" class="headerlink" title="接口中声明函数"></a>接口中声明函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    let result = source.search(subString);</span><br><span class="line">    return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数名可以不用匹配，下面这样也是可以的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src: string, sub: string): boolean &#123;</span><br><span class="line">    let result = src.search(sub);</span><br><span class="line">    return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Indexable-Types（可转换类型）"><a href="#Indexable-Types（可转换类型）" class="headerlink" title="Indexable Types（可转换类型）"></a>Indexable Types（可转换类型）</h5><p> Indexable types have an <em>index signature</em> that describes the types we can use to index into the object, along with the corresponding return types when indexing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;BOb&quot;,&quot;Fred&quot;]</span><br><span class="line">let myStr:string = myArray[0]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Above, we have a <code>StringArray</code> interface that has an index signature. This index signature states that when a <code>StringArray</code> is indexed with a <code>number</code>, it will return a <code>string</code>.</p>
<p>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a <code>number</code>, JavaScript will actually convert that to a <code>string</code> before indexing into an object. That means that indexing with <code>100</code> (a <code>number</code>) is the same thing as indexing with <code>&quot;100&quot;</code> (a <code>string</code>), so the two need to be consistent.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Error: indexing with a numeric string might get you a completely separate type of Animal!</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Animal;</span><br><span class="line">    [x: string]: Dog;</span><br><span class="line">    // 意思是这里的Animal与Dog应该换一下？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that <code>obj.property</code> is also available as <code>obj[&quot;property&quot;]</code>. In the following example, <code>name</code>’s type does not match the string index’s type, and the type-checker gives an error:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">    [index: string]: number;</span><br><span class="line">    length: number;    // ok, length is a number</span><br><span class="line">    name: string;      // error, the type of &apos;name&apos; is not a subtype of the indexer</span><br><span class="line">    //这里是说 name： number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, you can make index signatures readonly in order to prevent assignment to their indices:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ReadonlyStringArray &#123;</span><br><span class="line">    readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];</span><br><span class="line">myArray[2] = &quot;Mallory&quot;; // error!</span><br></pre></td></tr></table></figure>
<p> can’t set <code>myArray[2]</code> because the index signature is readonly</p>
<p>疑问：签名索引和这个可转换类型 相似</p>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date) &#123;</span><br><span class="line">        this.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</p>
<h5 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">    counter.interval = 123;</span><br><span class="line">    counter.reset = function () &#123; &#125;;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure>
<p>与第三方JavaScript交互时，可能需要使用上述模式来完整描述类型的形状</p>
<h4 id="3-类"><a href="#3-类" class="headerlink" title="3.类"></a>3.类</h4><p>传统的javascript构建可重用的组件是使用<strong>函数</strong>和<strong>基于原型的继承</strong></p>
<p>类的写法形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor(message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;Hello, &quot; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&quot;world&quot;);</span><br></pre></td></tr></table></figure>
<p>复杂的继承的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: number = 0) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">    move(distanceInMeters = 45) &#123;</span><br><span class="line">        console.log(&quot;Galloping...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br><span class="line"></span><br><span class="line">Slithering...</span><br><span class="line">Sammy the Python moved 5m.</span><br><span class="line">Galloping...</span><br><span class="line">Tommy the Palomino moved 34m</span><br></pre></td></tr></table></figure>
<p>tom 仍然使用的是Horse重写的move方法</p>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>public(默认)、private、protected</p>
<h6 id="private"><a href="#private" class="headerlink" title="private"></a>private</h6><blockquote>
<p>TypeScript是一种结构类型系统。当我们比较两种不同的类型时，无论它们来自何处，如果所有成员的类型都是兼容的，那么我们说类型本身是兼容的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rhino extends Animal &#123;</span><br><span class="line">    constructor() &#123; super(&quot;Rhino&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal(&quot;Goat&quot;);</span><br><span class="line">let rhino = new Rhino();</span><br><span class="line">let employee = new Employee(&quot;Bob&quot;);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; // Error: &apos;Animal&apos; and &apos;Employee&apos; are not compatible</span><br></pre></td></tr></table></figure>
<p>However, when comparing types that have <code>private</code> and <code>protected</code> members, we treat these types differently. For two types to be considered compatible, if one of them has a <code>private</code> member, then <strong>the other must have a <code>private</code>member that originated in the same declaration</strong>. The same applies to <code>protected</code> members.</p>
<p>我的理解：</p>
<p>虽然都是 Private 声明的同名变量，但一个是这个一个是那个，就像有两个具有相同属性的对象，还是不一样的，所以解释中说，必须来自同一个源,</p>
<h6 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h6><p>是可以在子类中访问，但是也是不可以在子类的外面访问的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(name: string) &#123; this.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">    private department: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, department: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getElevatorPitch() &#123;</span><br><span class="line">        return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</span><br><span class="line">console.log(howard.getElevatorPitch());</span><br><span class="line">console.log(howard.name); // error</span><br></pre></td></tr></table></figure>
<p>protected标记构造函数，这意味着该类不能在其包含的类之外实例化，但可以扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    protected constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Employee can extend Person</span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">    private department: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, department: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getElevatorPitch() &#123;</span><br><span class="line">        return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</span><br><span class="line">let john = new Person(&quot;John&quot;); // Error: The &apos;Person&apos; constructor is protected</span><br></pre></td></tr></table></figure>
<p>使用 protected 标记的构造函数，在类的外面是不能访问的，但是可以在子类中访问</p>
<ul>
<li>构造子类</li>
<li>子类构造方法中 super 调用父类的constructor</li>
</ul>
<p>但是是不可以直接在外面使用 new 的方法构造一个对象的。</p>
<p>又出现的readonly</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">    readonly numberOfLegs: number = 8;</span><br><span class="line">    constructor(readonly name: string) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/TypeScript/" rel="tag"># TypeScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/20/现代样式：css也要模块化/" rel="next" title="现代样式：CSS Modules">
                <i class="fa fa-chevron-left"></i> 现代样式：CSS Modules
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/assets/img/pic.jpg"
                alt="Gaomy" />
            
              <p class="site-author-name" itemprop="name">Gaomy</p>
              <p class="site-description motion-element" itemprop="description">gao's blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-关于基础类型-重点说-any、object等"><span class="nav-number">1.</span> <span class="nav-text">1.关于基础类型(重点说 any、object等)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#any"><span class="nav-number">1.1.</span> <span class="nav-text">any</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#object"><span class="nav-number">1.2.</span> <span class="nav-text">object</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Type-assertions—"><span class="nav-number">1.3.</span> <span class="nav-text">Type assertions—</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-interfaces-接口"><span class="nav-number">2.</span> <span class="nav-text">2.interfaces(接口)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#变量"><span class="nav-number">2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#index-signature-索引签名-—"><span class="nav-number">2.2.</span> <span class="nav-text">index signature(索引签名)—</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接口中声明函数"><span class="nav-number">2.3.</span> <span class="nav-text">接口中声明函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Indexable-Types（可转换类型）"><span class="nav-number">2.4.</span> <span class="nav-text">Indexable Types（可转换类型）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类"><span class="nav-number">2.5.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#混合类型"><span class="nav-number">2.6.</span> <span class="nav-text">混合类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类"><span class="nav-number">3.</span> <span class="nav-text">3.类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰符"><span class="nav-number">3.1.</span> <span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#private"><span class="nav-number">3.1.1.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#protected"><span class="nav-number">3.1.2.</span> <span class="nav-text">protected</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gaomy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
